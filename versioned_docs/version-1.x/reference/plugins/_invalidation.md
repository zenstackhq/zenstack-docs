The mutation hooks generated by ZenStack automatically invalidates the queries that are potentially affected by the changes. For example, if you create a `Post`, the `useFindManyPost` query will be automatically invalidated when the mutation succeeds. Invalidation causes cache to be purged and fresh data to be refetched.

The automatic invalidation takes care of nested read, write, and delete cascading.

**1. Nested Read**

Nested reads are also subject to automatic invalidation. For example, if you create a `Post`, the query made by

```ts
useFindUniqueUser({ where: { id: userId }, include: { posts: true } });
```

will be invalidated.

**2. Nested Write**

Similarly, nested writes also trigger automatic invalidation. For example, if you create a `Post` in a nested update to `User` like:

```ts
updateUser({ where: { id: userId }, posts: { create: { title: 'post1' } } });
```

The mutation will cause queries like ```useFindManyPost()``` to be invalidated.

**3. Delete Cascade**

In ZModel, relations can be configured to cascade delete, e.g.:

```zmodel
model User {
    ...
    posts Post[]
}

model Post {
    ...
    user User @relation(fields: [userId], references: [id], onDelete: Cascade)
    userId Int
}
```

When a `User` is deleted, the `Post` entities it owns will be deleted automatically. The generated hooks takes cascade delete into account. For example, if you delete a `User`, `Post` model will be considered as affected and queries like ```useFindManyPost()``` will be invalidated.
