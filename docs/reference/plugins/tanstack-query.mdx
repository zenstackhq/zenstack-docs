---
description: Plugin for generating Tanstack Query query and mutation hooks
sidebar_position: 6
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# @zenstackhq/tanstack-query

:::info
If you're looking for generating hooks for [SWR](https://swr.vercel.app/), please checkout the [`@zenstackhq/swr`](/docs/reference/plugins/swr) plugin.
:::

The `@zenstackhq/tanstack-query` plugin generates [Tanstack Query](https://tanstack.com/query/latest) hooks that call into the CRUD services provided by the [server adapters](/docs/category/server-adapters). The plugin currently supports React and Svelte. Vue support is coming soon.

The hooks syntactically mirror the APIs of a standard Prisma client, including the function names and shapes of parameters (hooks directly use types generated by Prisma).

To use the generated hooks, you need to install "tanstack-query" for the target framework with version 4.0.0 or above.

## Options

| Name    | Type   | Description                                             | Required | Default |
| ------- | ------ | ------------------------------------------------------- | -------- | ------- |
| output  | String | Output directory (relative to the path of ZModel)                                        | Yes      |         |
| target  | String | Target framework to generate for. Choose from "react" and "svelte".                                        | Yes      |         |
| useSuperJson  | Boolean | Use [superjson](https://github.com/blitz-js/superjson) for data serialization                                        | No      | false        |

## Context Provider

The plugin generates a context provider which you can use to configure the behavior of the hooks. The following options are available on the provider:

- endpoint

    The endpoint to use for the queries. Defaults to "/api/model".

- fetch

    A custom `fetch` function to use for the queries. Defaults to the browser's built-in `fetch`. 

Example for using the context provider:

<Tabs>

<Tab value="react" label="React">

```tsx
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { FetchFn, Provider as ZenStackHooksProvider } from '../lib/hooks';

// custom fetch function that adds a custom header
const myFetch: FetchFn = (url, options) => {
    options = options ?? {};
    options.headers = {
        ...options.headers,
        'x-my-custom-header': 'hello world',
    };
    return fetch(url, options);
};

const queryClient = new QueryClient();

function MyApp({ Component, pageProps: { session, ...pageProps } }: AppProps) {
    return (
        <QueryClientProvider client={queryClient}>
            <ZenStackHooksProvider value={{ endpoint: '/api/model', fetch: myFetch }}>
                <AppContent />
            </ZenStackHooksProvider>
        </QueryClientProvider>
    );
}

export default MyApp;
```

</Tab>

<Tab value="svelte" label="Svelte">

```svelte
<script lang="ts">
    import { QueryClient, QueryClientProvider } from '@tanstack/svelte-query';
    import { SvelteQueryContextKey, type FetchFn } from '$lib/hooks';
    import { setContext } from 'svelte';

    // custom fetch function that adds a custom header
    const myFetch: FetchFn = (url, options) => {
        options = options ?? {};
        options.headers = {
            ...options.headers,
            'x-my-custom-header': 'hello world',
        };
        return fetch(url, options);
    };

    setContext(SvelteQueryContextKey, {
        endpoint: '/api/model',
        fetch: myFetch,
    });

    const queryClient = new QueryClient();
</script>

<div>
    <QueryClientProvider client={queryClient}>
        <slot />
    </QueryClientProvider>
</div>
```
</Tab>

</Tabs>

## Example

Here's a quick example with a ReactJs blogging app. You can find a fully functional Todo app example [here](https://github.com/zenstackhq/sample-todo-nextjs-tanstack).

### Schema

```zmodel title='/schema.zmodel'
plugin hooks {
  provider = '@zenstackhq/tanstack-query'
  output = "./src/lib/hooks"
  target = "react"
}

model User {
  id            String    @id @default(cuid())
  email         String
  posts         Post[]

  // everyone can signup, and user profile is also publicly readable
  @@allow('create,read', true)
}

model Post {
  id        String @id @default(cuid())
  title     String
  published Boolean @default(false)
  author    User @relation(fields: [authorId], references: [id])
  authorId  String

  // author has full access
  @@allow('all', auth() == author)

  // logged-in users can view published posts
  @@allow('read', auth() != null && published)
}
```

### App Setup

<Tabs>

<TabItem value="react" label="React">

```tsx

import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { Provider as ZenStackHooksProvider } from '../lib/hooks';

const queryClient = new QueryClient();

function App({ Component, pageProps: { session, ...pageProps } }: AppProps) {
    return (
        <QueryClientProvider client={queryClient}>
            <ZenStackHooksProvider value={{ endpoint: '/api/model' }}>
                <AppContent />
            </ZenStackHooksProvider>
        </QueryClientProvider>
    );
}

```

</TabItem>

<TabItem value="svelte" label="Svelte">

```svelte

<script lang="ts">
    import { SvelteQueryContextKey } from '$lib/hooks';
    import { QueryClient, QueryClientProvider } from '@tanstack/svelte-query';
    import { setContext } from 'svelte';

    const queryClient = new QueryClient();
    setContext(SvelteQueryContextKey, { endpoint: '/api/model' });
</script>

<div>
    <QueryClientProvider client={queryClient}>
        <slot />
    </QueryClientProvider>
</div>

```

:::tip

If you're using [SvelteKit](https://kit.svelte.dev/), you need to make sure the package `@zenstackhq/tanstack-query` is not treated as an external dependency by Vite, otherwise you'll encounter errors when the SvelteKit server renders the app. To do this, add the following section into `vite.config.js`:

```js title='/vite.config.js'

const config = {
    ...
    ssr: {
        noExternal: ['@zenstackhq/tanstack-query'],
    },
};

export default config;

```
:::

</TabItem>

</Tabs>

### Using Query and Mutation Hooks

<Tabs>
<TabItem value="react" label="React">

```tsx title='/src/components/Posts.tsx'
import type { Post } from '@prisma/client';
import { useFindManyPost, useCreatePost } from '../lib/hooks';

// post list component
const Posts = ({ userId }: { userId: string }) => {
    const create = useCreatePost();

    // list all posts that're visible to the current user, together with their authors
    const { data: posts } = useFindManyPost({
        include: { author: true },
        orderBy: { createdAt: 'desc' },
    });

    async function onCreatePost() {
        create.mutate({
            data: {
                title: 'My awesome post',
                authorId: userId,
            },
        });
    }

    return (
        <>
            <button onClick={onCreatePost}>Create</button>
            <ul>
                {posts?.map((post) => (
                    <li key={post.id}>
                        {post.title} by {post.author.email}
                    </li>
                ))}
            </ul>
        </>
    );
};
```

</TabItem>

<TabItem value="svelte" label="Svelte">

```svelte title='/src/components/Posts.svelte'
<script lang="ts">
    import type { Post } from '@prisma/client';
    import { useFindManyPost, useCreatePost } from '../lib/hooks';

    export let userId: string;

    const query = useFindManyPost();
    const create = useCreatePost();

    function onCreatePost() {
        $create.mutate({
            data: {
                title: 'My awesome post',
                authorId: userId,
            },
        });
    }
</script>

<div>
    <button on:click={onCreatePost}>Create</button>
    <ul>
        {#each $query.data as post (post.id)}
            <li>{post.title} by {post.author.email}</li>
        {/each}
    </ul>
</div>
```

</TabItem>
</Tabs>

### Using Infinite Query

<Tabs>
<TabItem value="react" label="React">

See [Tanstack Query documentation](https://tanstack.com/query/v4/docs/react/guides/infinite-queries) for more details.

```tsx title='/src/components/Posts.tsx'
import type { Post } from '@prisma/client';
import { useInfiniteFindManyPost } from '../lib/hooks';

// post list component with infinite loading
const Posts = () => {
    const PAGE_SIZE = 10;

    const fetchArgs = {
        include: { author: true },
        orderBy: { createdAt: 'desc' as const },
        take: PAGE_SIZE,
    };

    const { data, fetchNextPage, hasNextPage } = useInfiniteFindManyPost(fetchArgs, {
        getNextPageParam: (lastPage, pages) => {
            if (lastPage.length < PAGE_SIZE) {
                return undefined;
            }
            const fetched = pages.flatMap((item) => item).length;
            return {
                ...fetchArgs,
                skip: fetched,
            };
        },
    });    

    return (
        <>
            <ul>
                {data?.pages.map((posts, i) => (
                    <React.Fragment key={i}>
                        {posts?.map((post) => (
                            <li key={post.id}>
                                {post.title} by {post.author.email}
                            </li>
                        ))}
                    </React.Fragment>
                ))}
            </ul>
            {hasNextPage && (
                <button onClick={() => fetchNextPage()}>
                    Load more
                </button>
            )}
        </>
    );
};
```

</TabItem>

<TabItem value="svelte" label="Svelte">

See [Tanstack Query documentation](https://tanstack.com/query/v4/docs/svelte/examples/svelte/load-more-infinite-scroll) for more details.

```svelte title='/src/components/Posts.svelte'
<script lang="ts">
    // post list component with infinite loading

    import type { Post } from '@prisma/client';
    import { useInfiniteFindManyPost } from '../lib/hooks';

    const PAGE_SIZE = 10;

    const fetchArgs = {
        include: { author: true },
        orderBy: { createdAt: 'desc' as const },
        take: PAGE_SIZE,
    };

    const query = useInfiniteFindManyPost(fetchArgs, {
        getNextPageParam: (lastPage, pages) => {
            if (lastPage.length < PAGE_SIZE) {
                return undefined;
            }
            const fetched = pages.flatMap((item) => item).length;
            return {
                ...fetchArgs,
                skip: fetched,
            };
        },
    });    
</script>

<div>
    <ul>
        <div>
            {#if $query.data}
                {#each $query.data.pages as posts, i (i)}
                    {#each posts as post (post.id)}
                        <li>{post.title} by {post.author.email}</li>
                    {/each}
                {/each}
            {/if}
        </div>
    </ul>
    {#if $query.hasNextPage}
        <button on:click={() => $query.fetchNextPage()}>
            Load more
        </button>
    {/if}
</div>
```

</TabItem>
</Tabs>
