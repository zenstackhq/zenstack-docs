---
description: Plugin for generating React data query hooks
sidebar_position: 5
---

# @zenstackhq/react

The `@zenstack/react` plugin generates React hooks that call into the CRUD services provided by packages like [`@zenstack/next`](/docs/reference/server-adapters/next).

The hooks syntactically mirror the APIs of a standard Prisma client, including the function names and shapes of parameters (hooks directly use types generated by Prisma). You can choose to use [SWR](https://swr.vercel.app/) or [react-query](https://tanstack.com/query/latest/) for data fetching.

## Options

| Name    | Type   | Description                                             | Required | Default |
| ------- | ------ | ------------------------------------------------------- | -------- | ------- |
| output  | String | Output directory                                        | Yes      |         |
| fetcher | String | The data fetcher library to use: "swr" or "react-query" |          | "swr"   |

## Description

### SWR

When using "swr" as data fetcher, you need to install "swr" version 2.0.0 or above.

### react-query

When using "react-query" as data fetcher, you need to install "@tanstack/react-query" version 4.0.0 or above.

:::info
The latest version of "react-query" has a known JS bundling issue when used with Next.js. If you see the following error:

```
No QueryClient set, use QueryClientProvider to set one
```

, even you've already set up `<QueryClient />` properly as stated in the [documentation](https://tanstack.com/query/latest/docs/react/quick-start), please try adding the following code to `next.config.js` to dedupe the "@tanstack/react-query" package:

```js
const config = {
    // ... other config

    webpack: (config, options) => {
        if (options.isServer) {
            config.externals = ['@tanstack/react-query', ...config.externals];
        }

        const reactQuery = path.resolve(require.resolve('@tanstack/react-query'));
        config.resolve.alias['@tanstack/react-query'] = reactQuery;
        return config;
    },
};
```

We're actively investigating a better solution to this issue, but right now you'll have to use this workaround.

Special thanks to [@ecyrbe](https://github.com/ecyrbe) for suggesting this workaround!

:::

## Example

Here's an example with a blogging app:

```prisma title='/schema.zmodel'
plugin reactHooks {
  provider = '@zenstackhq/react'
  output = "./src/lib/hooks"
}

model User {
  id            String    @id @default(cuid())
  email         String
  posts         Post[]

  // everyone can signup, and user profile is also publicly readable
  @@allow('create,read', true)
}

model Post {
  id        String @id @default(cuid())
  title     String
  published Boolean @default(false)
  author    User @relation(fields: [authorId], references: [id])
  authorId  String

  // author has full access
  @@allow('all', auth() == author)

  // logged-in users can view published posts
  @@allow('read', auth() != null && published)
}
```

```tsx title='/src/components/posts.tsx'
import type { Post } from '@prisma/client';
import { usePost } from '../lib/hooks';

// post list component
const Posts = ({ userId }: { userId: string }) => {
    // Post crud hooks
    const { findMany, create } = usePost();

    // list all posts that're visible to the current user, together with their authors
    const { data: posts } = findMany({
        include: { author: true },
        orderBy: { createdAt: 'desc' },
    });

    async function onCreatePost() {
        await create({
            data: {
                title: 'My awesome post',
                authorId: userId,
            },
        });
    }

    return (
        <>
            <button onClick={onCreatePost}>Create</button>
            <ul>
                {posts?.map((post) => (
                    <li key={post.id}>
                        {post.title} by {post.author.email}
                    </li>
                ))}
            </ul>
        </>
    );
};
```
